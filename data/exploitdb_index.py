#!/usr/bin/env python3
"""
ExploitDB CSV indexer

- Parses exploitdb.csv and builds a CVE -> exploits metadata index
- Provides helpers to derive internal vulnerability types from exploit metadata
"""

import csv
import os
import re
from typing import Dict, List, Any, Optional


class ExploitDBIndex:
    _instance: Optional["ExploitDBIndex"] = None

    def __init__(self, csv_path: str):
        self.csv_path = csv_path
        self._cve_to_exploits: Dict[str, List[Dict[str, Any]]] = {}
        self._loaded: bool = False

    @classmethod
    def get_instance(cls, csv_path: Optional[str] = None) -> "ExploitDBIndex":
        if cls._instance is None:
            # Default to repo root exploitdb.csv if not provided
            resolved = csv_path or os.path.join(os.path.dirname(os.path.dirname(__file__)), "exploitdb.csv")
            cls._instance = ExploitDBIndex(resolved)
        return cls._instance

    def ensure_loaded(self) -> None:
        if self._loaded:
            return
        if not os.path.exists(self.csv_path):
            # File not available; keep index empty but marked loaded
            self._loaded = True
            return

        with open(self.csv_path, newline='', encoding='utf-8', errors='ignore') as f:
            reader = csv.DictReader(f)
            for row in reader:
                codes_field = (row.get("codes") or "").strip()
                if not codes_field:
                    continue
                codes = [c.strip() for c in codes_field.split(';') if c.strip()]
                # Extract CVE tokens from codes (e.g., "CVE-2019-1234")
                cve_tokens = [c for c in codes if c.upper().startswith("CVE-")]
                if not cve_tokens:
                    continue
                meta = {
                    "id": row.get("id"),
                    "file": row.get("file"),
                    "description": row.get("description") or "",
                    "date_published": row.get("date_published"),
                    "author": row.get("author"),
                    "type": (row.get("type") or "").lower(),
                    "platform": (row.get("platform") or "").lower(),
                    "port": row.get("port") or "",
                    "verified": row.get("verified"),
                    "tags": row.get("tags") or "",
                    "aliases": row.get("aliases") or "",
                    "source_url": row.get("source_url") or "",
                }
                for cve in cve_tokens:
                    key = cve.upper()
                    self._cve_to_exploits.setdefault(key, []).append(meta)
        self._loaded = True

    def get_exploits_for_cve(self, cve_id: str) -> List[Dict[str, Any]]:
        if not cve_id:
            return []
        self.ensure_loaded()
        return self._cve_to_exploits.get(cve_id.upper(), [])


_INJECTION_TERMS = [
    "sql injection", "sqli", "xpath injection", "ldap injection", "command injection",
    "code injection", "injection", "nosql", "sqli",
]
_XSS_TERMS = ["xss", "cross-site scripting", "cross site scripting"]
_RCE_TERMS = ["remote code execution", "rce", "code execution", "remote execution"]
_TRAVERSAL_TERMS = ["path traversal", "directory traversal", "../", "..\\"]
_LFI_TERMS = ["local file inclusion", "lfi"]
_RFI_TERMS = ["remote file inclusion", "rfi"]
_AUTH_BYPASS_TERMS = ["auth bypass", "authentication bypass", "bypass authentication"]
_PRIV_ESC_TERMS = ["privilege escalation", "elevation of privilege", "eop"]
_CSRF_TERMS = ["csrf", "cross-site request forgery", "cross site request forgery"]
_XXE_TERMS = ["xxe", "xml external entity"]
_INFO_DISC_TERMS = ["information disclosure", "info disclosure", "data leak", "expose"]
_DEFAULT_CREDS_TERMS = ["default credentials", "default password"]
_DESERIAL_TERMS = ["insecure deserialization", "deserialization", "deserialize"]


def _match_any(text: str, terms: List[str]) -> bool:
    t = text.lower()
    return any(term in t for term in terms)


def derive_types_from_exploit_metadata(exploits: List[Dict[str, Any]]) -> List[str]:
    types: List[str] = []
    if not exploits:
        return types

    for e in exploits:
        etype = (e.get("type") or "").lower()
        desc = (e.get("description") or "").lower()
        platform = (e.get("platform") or "").lower()

        # Primary by explicit exploit type folder names
        if etype in ("webapps", "remote", "dos", "local", "multiple", "shellcode"):
            # Use description to refine to our internal categories
            pass

        # Description heuristics to internal types
        if _match_any(desc, _INJECTION_TERMS):
            if "sql" in desc or "nosql" in desc:
                types.append("sql_injection")
            elif "command" in desc:
                types.append("command_injection")
            else:
                types.append("code_injection")

        if _match_any(desc, _XSS_TERMS):
            types.append("xss")
        if _match_any(desc, _RCE_TERMS):
            types.append("rce")
        if _match_any(desc, _TRAVERSAL_TERMS):
            types.append("path_traversal")
        if _match_any(desc, _LFI_TERMS):
            types.append("lfi")
        if _match_any(desc, _RFI_TERMS):
            types.append("rfi")
        if _match_any(desc, _AUTH_BYPASS_TERMS):
            types.append("authentication_bypass")
        if _match_any(desc, _PRIV_ESC_TERMS):
            types.append("privilege_escalation")
        if _match_any(desc, _CSRF_TERMS):
            types.append("csrf")
        if _match_any(desc, _XXE_TERMS):
            types.append("xxe")
        if _match_any(desc, _INFO_DISC_TERMS):
            types.append("information_disclosure")
        if _match_any(desc, _DEFAULT_CREDS_TERMS):
            types.append("default_credentials")
        if _match_any(desc, _DESERIAL_TERMS):
            types.append("insecure_deserialization")

        # Platform hints
        if platform in ("php", "asp", "aspx", "jsp", "perl"):
            if "webapps" not in types:
                types.append("webapps")  # just a hint, not used directly in OWASP mapping

    # Always include known_cves if we had any exploit mapping
    if exploits and "known_cves" not in types:
        types.append("known_cves")

    # De-duplicate preserving order
    seen = set()
    deduped = []
    for t in types:
        if t not in seen:
            seen.add(t)
            deduped.append(t)
    return deduped


